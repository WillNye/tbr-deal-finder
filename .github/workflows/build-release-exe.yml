name: Build and Attach Windows EXE to Release

on:
  release:
    types: [created]

permissions:
  contents: write
  
jobs:
  build-exe:
    runs-on: windows-latest
    env:
      HAS_WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE != '' }}
      HAS_WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD != '' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'

    - name: Install uv
      uses: astral-sh/setup-uv@v5
        
    - name: Install project dependencies
      run: |
        uv sync

    - name: Set up Visual Studio Build Tools (for Flet)
      uses: microsoft/setup-msbuild@v2
      with:
        msbuild-architecture: x64
        
    - name: Install Visual C++ Build Tools
      run: |
        # Install Visual C++ Redistributable and build tools needed for Flet
        choco install visualcppbuildtools -y
        choco install vcredist-all -y
      
    - name: Find and configure SignTool
      run: |
        # Find signtool.exe in Windows SDK
        $signtoolPaths = @(
          "${env:ProgramFiles(x86)}\Windows Kits\10\bin\*\x64\signtool.exe",
          "${env:ProgramFiles}\Windows Kits\10\bin\*\x64\signtool.exe",
          "${env:ProgramFiles(x86)}\Microsoft SDKs\Windows\*\bin\*\signtool.exe"
        )
        
        $signtoolPath = $null
        foreach ($path in $signtoolPaths) {
          $found = Get-ChildItem -Path $path -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($found) {
            $signtoolPath = $found.FullName
            break
          }
        }
        
        if ($signtoolPath) {
          Write-Output "‚úÖ Found SignTool at: $signtoolPath"
          $signtoolDir = Split-Path -Parent $signtoolPath
          Write-Output "SIGNTOOL_PATH=$signtoolPath" >> $env:GITHUB_ENV
          Write-Output "SIGNTOOL_DIR=$signtoolDir" >> $env:GITHUB_ENV
          Write-Output "$signtoolDir" >> $env:GITHUB_PATH
        } else {
          Write-Output "‚ùå SignTool not found, code signing will be skipped"
        }

    - name: Import Code Signing Certificate (if available)
      if: ${{ env.HAS_WINDOWS_CERTIFICATE == 'true' && env.HAS_WINDOWS_CERTIFICATE_PASSWORD == 'true' }}
      run: |
        # Decode and import certificate
        $certBytes = [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CERTIFICATE }}")
        $certPath = "windows-cert.pfx"
        [System.IO.File]::WriteAllBytes($certPath, $certBytes)
        
        # Import certificate to certificate store
        $securePassword = ConvertTo-SecureString -String "${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}" -Force -AsPlainText
        Import-PfxCertificate -FilePath $certPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        
        Write-Output "‚úÖ Code signing certificate imported successfully"
        
        # Clean up certificate file
        Remove-Item $certPath -Force
        
    - name: Build Windows EXE
      env:
        PYTHONIOENCODING: utf-8
        PYTHONLEGACYWINDOWSFSENCODING: utf-8
        # Disable Rich progress bars to avoid Unicode issues
        TERM: dumb
        NO_COLOR: 1
        # Ensure Python runtime is bundled
        FLET_BUILD_VERBOSE: 1
      run: |
        # Set console to UTF-8 to handle Unicode characters
        chcp 65001
        
        # Use flet to build Windows executable with verbose output
        Write-Output "ü™ü Building Windows executable..."
        uv run flet build windows --output gui_dist/ --verbose --include-packages flet,flet_desktop
        
        Write-Output "üìÅ Build output contents:"
        Get-ChildItem -Path gui_dist -Recurse | Format-Table Name, Length, LastWriteTime
        
        # Check if critical Python runtime DLLs are present
        Write-Output "üîç Checking for Python runtime DLLs..."
        $exeDir = (Get-ChildItem -Path "gui_dist" -Filter "*.exe" -Recurse | Select-Object -First 1).Directory.FullName
        if ($exeDir) {
          Write-Output "EXE Directory: $exeDir"
          
          $pythonDlls = @("python*.dll", "*python*.dll", "serious_python*.dll")
          $missingDlls = @()
          
          foreach ($pattern in $pythonDlls) {
            $found = Get-ChildItem -Path $exeDir -Filter $pattern -Recurse -ErrorAction SilentlyContinue
            if ($found) {
              Write-Output "‚úÖ Found: $($found.Name) in $($found.DirectoryName)"
            } else {
              $missingDlls += $pattern
            }
          }
          
          # If serious_python DLL is missing, try to find and copy it from Python installation
          if ($missingDlls -contains "serious_python*.dll") {
            Write-Output "‚ö†Ô∏è  serious_python DLL missing, attempting to locate and copy..."
            
            # Check common Python locations
            $pythonPaths = @(
              "$env:HOSTEDTOOLCACHE\Python\*\*\DLLs",
              "$env:PYTHON_HOME\DLLs",
              "C:\Python*\DLLs",
              "C:\hostedtoolcache\windows\Python\*\*\DLLs"
            )
            
            foreach ($pythonPath in $pythonPaths) {
              $foundDll = Get-ChildItem -Path $pythonPath -Filter "serious_python*.dll" -ErrorAction SilentlyContinue
              if ($foundDll) {
                Write-Output "üì¶ Found DLL at: $($foundDll.FullName)"
                Copy-Item -Path $foundDll.FullName -Destination $exeDir -Force
                Write-Output "‚úÖ Copied serious_python DLL to executable directory"
                break
              }
            }
          }
        }
        
    - name: Sign Windows EXE (if certificate and SignTool available)
      if: ${{ env.HAS_WINDOWS_CERTIFICATE == 'true' && env.HAS_WINDOWS_CERTIFICATE_PASSWORD == 'true' && env.SIGNTOOL_PATH != '' }}
      run: |
        # Find the executable
        $exePath = Get-ChildItem -Path "gui_dist" -Filter "*.exe" -Recurse | Select-Object -First 1
        if (-not $exePath) {
          Write-Output "‚ùå No executable found in gui_dist/"
          exit 1
        }
        
        Write-Output "üîê Signing Windows executable: $($exePath.FullName)"
        Write-Output "üìç Using SignTool: $env:SIGNTOOL_PATH"
        
        # Sign with self-signed certificate using full path
        try {
          & "$env:SIGNTOOL_PATH" sign /n "TBR Deal Finder" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 $exePath.FullName
          Write-Output "‚úÖ Windows executable signed successfully"
        }
        catch {
          Write-Output "‚ö†Ô∏è  Timestamped signing failed, trying without timestamp..."
          try {
            & "$env:SIGNTOOL_PATH" sign /s My /n "TBR Deal Finder" /fd SHA256 $exePath.FullName
            Write-Output "‚úÖ Windows executable signed successfully (without timestamp)"
          }
          catch {
            Write-Output "‚ùå Both signing methods failed"
            Write-Output "Certificate store contents:"
            Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*TBR Deal Finder*"} | Format-List Subject, Thumbprint, NotAfter
            throw "Code signing failed"
          }
        }
        
    - name: Skip signing message (if SignTool not available)
      if: ${{ env.HAS_WINDOWS_CERTIFICATE == 'true' && env.HAS_WINDOWS_CERTIFICATE_PASSWORD == 'true' && env.SIGNTOOL_PATH == '' }}
      run: |
        Write-Output "‚ö†Ô∏è  SignTool not found - executable will not be signed"
        Write-Output "   The executable will still work but may show security warnings"
        
    - name: Find and verify EXE was created
      id: find-exe
      run: |
        $exeFile = Get-ChildItem -Path "gui_dist" -Filter "*.exe" -Recurse | Select-Object -First 1
        if (-not $exeFile) {
          Write-Output "‚ùå EXE file not found!"
          Write-Output "Contents of gui_dist/:"
          Get-ChildItem -Path "gui_dist" -Recurse | Format-Table
          exit 1
        }
        
        Write-Output "‚úÖ EXE file created successfully: $($exeFile.FullName)"
        Write-Output "exe_path=$($exeFile.FullName)" >> $env:GITHUB_OUTPUT
        Write-Output "exe_name=$($exeFile.Name)" >> $env:GITHUB_OUTPUT
        
    - name: Get EXE info
      id: exe-info
      run: |
        $exePath = "${{ steps.find-exe.outputs.exe_path }}"
        $exeSize = [math]::Round((Get-Item $exePath).Length / 1MB, 1)
        Write-Output "size=$($exeSize)MB" >> $env:GITHUB_OUTPUT
        Write-Output "üì¶ EXE Size: $($exeSize)MB"
        Write-Output "üì¶ EXE Name: ${{ steps.find-exe.outputs.exe_name }}"
        
        # Check if signed
        try {
          $signature = Get-AuthenticodeSignature -FilePath $exePath
          if ($signature.Status -eq "Valid") {
            Write-Output "‚úÖ Executable is properly signed"
          } elseif ($signature.Status -eq "UnknownError") {
            Write-Output "‚ö†Ô∏è  Executable is self-signed (users will see security warnings)"
          } else {
            Write-Output "‚ÑπÔ∏è  Executable signature status: $($signature.Status)"
          }
        }
        catch {
          Write-Output "‚ÑπÔ∏è  Could not verify signature"
        }
        
    - name: Upload EXE to Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        gh release upload ${{ github.event.release.tag_name }} `
          "${{ steps.find-exe.outputs.exe_path }}" `
          --clobber `
          --repo ${{ github.repository }}
